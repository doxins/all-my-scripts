-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local SoundService = game:GetService("SoundService")

-- Find MainEvent
local function MainEventLocate()
    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
        if v.Name == "MainEvent" then
            return v
        end
    end
    return nil
end
local MainEvent = MainEventLocate()

-- Variables
local toggleState = false
local macro_in_use = false
local last_macro_instruction = 0
local lastReloadTime = 0
local isReloading = false
local spreadModActive = true
local noClipActive = false
local lastNoClipToggle = os.clock()
local aimAssistToggleState = false
local silentAimToggleState = false
local lastMousePos = Vector2.new(Mouse.X, Mouse.Y)
local Locking = false
local Plr = nil
local lockCooldown = 0
local spawnTimes = {}
local isMouseHeld = false
local macroActive = false
local espToggleState = true

-- Silent Aim Variables
local FOVCircle = Drawing.new("Circle")
FOVCircle.Color = shared.global['SilentAim']['FOV']['Color']
FOVCircle.Thickness = shared.global['SilentAim']['FOV']['Thickness']
FOVCircle.Filled = false
FOVCircle.Transparency = shared.global['SilentAim']['FOV']['Transparency']

-- ESP Logic
local function CreateNameESP(player)
    if not shared.global['ESP']['Enabled'] or not espToggleState then return end
    if not player or not player.Character or not player.Character:FindFirstChild("Head") then return end
    local nameTag = Instance.new("BillboardGui")
    nameTag.Name = "NameESP"
    nameTag.Adornee = player.Character.Head
    nameTag.Size = UDim2.new(0, 100, 0, 50)
    nameTag.StudsOffset = Vector3.new(0, 2, 0)
    nameTag.AlwaysOnTop = true
    nameTag.Parent = player.Character
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = (shared.global['ESP']['Type'] == "Display" and player.DisplayName) or player.Name
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextSize = 14
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.Parent = nameTag
end

local function UpdateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local existing = player.Character:FindFirstChild("NameESP")
            if existing then
                existing:Destroy()
            end
            CreateNameESP(player)
        end
    end
end

-- Initialize ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer and player.Character then
        CreateNameESP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(character)
            character:WaitForChild("Head")
            CreateNameESP(player)
        end)
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode[shared.global['ESP']['ToggleKey']:upper()] then
        espToggleState = not espToggleState
        UpdateESP()
    end
end)

-- Weapon Categories
local WeaponCategories = {
    flintlock = "Pistols", glock = "Pistols", revolver = "Pistols", silencer = "Pistols",
    ["double-barrel sg"] = "Shotguns", ["drum-shotgun"] = "Shotguns", tacticalshotgun = "Shotguns",
    ar = "Automatics", silencerar = "Automatics", lmg = "Automatics", smg = "Automatics",
    p90 = "Automatics", ak47 = "Automatics", drumgun = "Automatics", aug = "Automatics",
    rifle = "Other", ["money gun"] = "Other", rpg = "Other", flamethrower = "Other", taser = "Other", grenadelauncher = "Other"
}

-- Valid Body Parts
local ValidBodyParts = {
    "Head", "HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso",
    "LeftArm", "LeftUpperArm", "LeftLowerArm", "RightArm", "RightUpperArm", "RightLowerArm",
    "LeftLeg", "LeftUpperLeg", "LeftLowerLeg", "RightLeg", "RightUpperLeg", "RightLowerLeg"
}

-- NoClip Logic
local function getNoClipTool(slot)
    local coreGui = game:GetService("CoreGui")
    local hotbar = coreGui:FindFirstChild("RobloxGui") and coreGui.RobloxGui:FindFirstChild("Backpack") and coreGui.RobloxGui.Backpack:FindFirstChild("Hotbar")
    if hotbar then
        for _, v in pairs(hotbar:GetChildren()) do
            if v.Name:find(tostring(slot)) then
                return v.ToolName.Text
            end
        end
    end
    return nil
end

local function handleNoClip()
    if not shared.global['Macros']['NoClip']['Enabled'] then
        noClipActive = false
        return
    end
    
    local char = LocalPlayer.Character
    if not char then
        noClipActive = false
        return
    end
    
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then
        noClipActive = false
        return
    end
    
    local currentTime = os.clock()
    if currentTime - lastNoClipToggle < shared.global['Macros']['NoClip']['Delay'] then
        return
    end
    
    if noClipActive then
        local toolName = getNoClipTool(shared.global['Macros']['NoClip']['WeaponSlot'])
        if toolName and LocalPlayer.Backpack:FindFirstChild(toolName) then
            hum:EquipTool(LocalPlayer.Backpack:FindFirstChild(toolName))
        else
            hum:UnequipTools()
        end
        lastNoClipToggle = currentTime
    elseif hum:GetState() == Enum.HumanoidStateType.RunningNoPhysics then
        hum:UnequipTools()
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent or not shared.global['Macros']['NoClip']['Enabled'] then return end
    
    if input.KeyCode == Enum.KeyCode[shared.global['Macros']['NoClip']['Keybind']:upper()] then
        if shared.global['Macros']['NoClip']['Mode']:lower() == "toggle" then
            noClipActive = not noClipActive
        elseif shared.global['Macros']['NoClip']['Mode']:lower() == "hold" then
            noClipActive = true
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent or not shared.global['Macros']['NoClip']['Enabled'] then return end
    
    if input.KeyCode == Enum.KeyCode[shared.global['Macros']['NoClip']['Keybind']:upper()] then
        if shared.global['Macros']['NoClip']['Mode']:lower() == "hold" then
            noClipActive = false
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    noClipActive = false
    isReloading = false
    spawnTimes[LocalPlayer] = os.clock()
end)

RunService.Heartbeat:Connect(handleNoClip)

-- Track player spawns
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        spawnTimes[player] = os.clock()
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    spawnTimes[player] = nil
end)

-- Function to play a sound
local function PlaySound(soundId, volume)
    local sound = Instance.new("Sound")
    sound.SoundId = soundId
    sound.Volume = volume or 0.5
    sound.Parent = SoundService
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
    sound:Play()
end

-- Function to get current equipped gun name
local function GetEquippedGunName()
    local character = LocalPlayer.Character
    if not character then return nil end
    local tool = character:FindFirstChildOfClass("Tool")
    if not tool then return nil end
    
    local toolName = tool.Name:gsub("%[", ""):gsub("%]", "")
    
    if toolName:lower():find("double") or toolName:lower():find("db") then
        return "Double-Barrel Sg"
    elseif toolName:lower():find("tactical") then
        return "Tactical Shotgun"
    elseif toolName:lower():find("shotgun") then
        return "Shotgun"
    end
    
    return nil
end

-- Function to get the current spread modifier for the equipped gun
local function GetSpreadModifier()
    if not spreadModActive then return 1 end
    
    local gunName = GetEquippedGunName()
    if not gunName then return 1 end
    
    local spreadConfig = shared.global['Weapon Modifications']['Spread Modifications']
    local method = spreadConfig['Method']
    
    if method == "Basic" then
        return spreadConfig[gunName]
    elseif method == "Randomized" then
        local minSpread = spreadConfig['Randomization'][gunName]['Min']
        local maxSpread = spreadConfig['Randomization'][gunName]['Max']
        local randomSpread = math.random(math.floor(minSpread * 1000), math.floor(maxSpread * 1000)) / 1000
        return randomSpread
    end
    
    return 1
end

-- Input handler for toggling spread mods with sound feedback
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not shared.global['Weapon Modifications']['Spread Modifications']['Activation']['Enabled'] then return end
    if input.KeyCode == Enum.KeyCode[shared.global['Weapon Modifications']['Spread Modifications']['Activation']['Keybind']:upper()] then
        spreadModActive = not spreadModActive
        if spreadModActive then
            PlaySound("rbxassetid://1788243907", 1)
        else
            PlaySound("rbxassetid://9125609918", 2)
        end
    end
end)

-- Spread modification hook
local old; old = hookfunction(math.random, function(...)
    local args = {...}
    
    if checkcaller() then
        return old(...)
    end
    
    if (#args == 0) or 
       (args[1] == -0.05 and args[2] == 0.05) or 
       (args[1] == -0.1) or
       (args[1] == -0.05) then
        if spreadModActive then
            local spreadModifier = GetSpreadModifier()
            return old(...) * spreadModifier
        end
    end
    
    return old(...)
end)

-- Macro Logic
local function builtin_macro_function()
    if not macroActive then return end
    if not macro_in_use and os.clock() - last_macro_instruction >= (shared.global['Macros']['Normal']['Speed']['Delay'] or 0.020) then
        task.spawn(function()
            macro_in_use = true
            if shared.global['Macros']['Normal']['Speed']['Enabled'] then
                if VirtualInputManager then
                    task.wait(shared.global['Macros']['Normal']['Speed']['Delay'] / 2)
                    VirtualInputManager:SendMouseWheelEvent(0, 0, true, game)
                    task.wait(shared.global['Macros']['Normal']['Speed']['Delay'] / 2)
                    VirtualInputManager:SendMouseWheelEvent(0, 0, false, game)
                end
            else
                LocalPlayer.CameraMaxZoomDistance = 30
                task.wait()
                LocalPlayer.CameraMinZoomDistance = 0.5
            end
            last_macro_instruction = os.clock()
            macro_in_use = false
        end)
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not shared.global['Macros']['Normal']['Enabled'] then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode[shared.global['Macros']['Normal']['Keybind']:upper()] then
        if shared.global['Macros']['Normal']['Mode'] == 'toggle' then
            macroActive = not macroActive
        elseif shared.global['Macros']['Normal']['Mode'] == 'hold' then
            macroActive = true
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed or not shared.global['Macros']['Normal']['Enabled'] then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode[shared.global['Macros']['Normal']['Keybind']:upper()] then
        if shared.global['Macros']['Normal']['Mode'] == 'hold' then
            macroActive = false
        end
    end
end)

local function equipKnifeOnReload()
    if not shared.global['ExtraFeatures']['KnifeOnReload']['Enabled'] then return end
    
    if shared.global['Macros']['Normal']['Enabled'] and macroActive or noClipActive then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    local bodyEffects = character:FindFirstChild("BodyEffects")
    if not bodyEffects then return end
    local currentReloadState = bodyEffects:FindFirstChild("Reload") and bodyEffects.Reload.Value
    if currentReloadState and not isReloading then
        if os.clock() - lastReloadTime >= shared.global['ExtraFeatures']['KnifeOnReload']['Delay'] then
            local knife = LocalPlayer.Backpack:FindFirstChild("[Knife]")
            if knife then
                humanoid:EquipTool(knife)
                lastReloadTime = os.clock()
            end
        end
    end
    isReloading = currentReloadState
end

-- Hitbox Expander Logic
local function handleHitboxExpander()
    if not shared.global['HitboxExpansion']['Enabled'] then return end
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character then
            for _, bodyPart in pairs(v.Character:GetChildren()) do
                if bodyPart:IsA("Part") then
                    bodyPart.Size = shared.global['HitboxExpansion']['PartSize']
                end
            end
        end
    end
end

-- AutoGetUp Logic
local function handleAutoGetUp()
    if not shared.global['ExtraFeatures']['AutoGetUp']['Enabled'] then return end
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    if humanoid:GetState() == Enum.HumanoidStateType.FallingDown then
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end
end

RunService.RenderStepped:Connect(function()
    handleAutoGetUp()
    equipKnifeOnReload()
    handleHitboxExpander()
    if shared.global['Macros']['Normal']['Enabled'] and macroActive then
        builtin_macro_function()
    end
end)

-- Fake Spike Logic
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not shared.global['FakeSpike']['Enabled'] then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode[shared.global['FakeSpike']['Bind']:upper()] then
        task.spawn(function()
            settings():GetService("NetworkSettings").IncomingReplicationLag = 99999
            if shared.global['FakeSpike']['KickOnSpike'] then
                task.wait(shared.global['FakeSpike']['TimeBeforeKick'])
                LocalPlayer:Kick("Lost connection to game server, Please rejoin")
            else
                task.wait(shared.global['FakeSpike']['Duration'])
                settings():GetService("NetworkSettings").IncomingReplicationLag = 0
            end
        end)
    end
end)

-- Universal Checks
local function PlayerCheck(player, config)
    if not player or not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then return false end
    
    if config['Filters']['CrewCheck'] then
        local PlaceId = game.PlaceId
        if table.find({5602055394, 7951883376}, PlaceId) then
            local OurInfo = LocalPlayer:FindFirstChild("Information")
            local TheirInfo = player:FindFirstChild("Information")
            if not OurInfo or not TheirInfo then return false end
            local ourCrew = OurInfo:FindFirstChild("Crew") and OurInfo.Crew.Value or ""
            local theirCrew = TheirInfo:FindFirstChild("Crew") and TheirInfo.Crew.Value or ""
            if ourCrew ~= "" and theirCrew ~= "" and ourCrew == theirCrew then return false end
        else
            local OurFolder = LocalPlayer:FindFirstChild("DataFolder")
            local TheirFolder = player:FindFirstChild("DataFolder")
            if not OurFolder or not TheirFolder then return false end
            local OurInfo = OurFolder:FindFirstChild("Information")
            local TheirInfo = TheirFolder:FindFirstChild("Information")
            if not OurInfo or not TheirInfo then return false end
            local ourCrew = OurInfo:FindFirstChild("Crew") and OurInfo.Crew.Value or ""
            local theirCrew = TheirInfo:FindFirstChild("Crew") and TheirInfo.Crew.Value or ""
            if ourCrew ~= "" and theirCrew ~= "" and ourCrew == theirCrew then return false end
        end
    end
    
    if config['Filters']['KnockCheck'] then
        local effects = player.Character:FindFirstChild("BodyEffects")
        if effects then
            local ko = effects:FindFirstChild("K.O") or effects:FindFirstChild("KO")
            if ko and ko.Value then return false end
        end
    end
    
    if config['Filters']['Forcefield'] then
        if player.Character:FindFirstChildOfClass("ForceField") then return false end
        local spawnTime = spawnTimes[player]
        if spawnTime and os.clock() - spawnTime < 10 then return false end
    end
    
    return true
end

local function IsBehindWall(target, config)
    if not target or not config['Filters']['WallCheck'] then return false end
    local origin = Camera.CFrame.Position
    local targetPos = target.Position
    local direction = (targetPos - origin).Unit * 1000
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character or {}}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local ray = Workspace:Raycast(origin, direction, params)
    return ray and ray.Instance and not ray.Instance:IsDescendantOf(target.Parent)
end

local function IsSelfKnocked()
    if not shared.global['AimAssist']['Checks']['SelfDeath'] then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local effects = character:FindFirstChild("BodyEffects")
    if not effects then return true end
    local ko = effects:FindFirstChild("K.O") or effects:FindFirstChild("KO")
    return ko and ko.Value or false
end

local function IsReloading()
    if not shared.global['AimAssist']['Checks']['Reload'] then return true end
    local character = LocalPlayer.Character
    if not character then return true end
    local bodyEffects = character:FindFirstChild("BodyEffects")
    if not bodyEffects then return true end
    local reload = bodyEffects:FindFirstChild("Reload")
    return reload and not reload.Value or true
end

local function DisableOnThirdPerson()
    if not shared.global['AimAssist']['Checks']['ThirdPerson'] then return true end
    return (Camera.CFrame.Position - Camera.Focus.Position).Magnitude < 0.7 and UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter
end

local function CheckHoldingGun()
    if not shared.global['AimAssist']['Checks']['RequireGun'] then return true end
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    local tool = character:FindFirstChildOfClass("Tool")
    return tool and tool.Name ~= "[Knife]" or false
end

-- Silent Aim Logic
local function GetEquippedTool()
    local character = LocalPlayer.Character
    if not character then return nil end
    local tool = character:FindFirstChildOfClass("Tool")
    return tool and tool.Name or nil
end

local function GetWeaponCategory()
    local toolName = GetEquippedTool()
    if not toolName then return nil end
    return WeaponCategories[toolName:lower():gsub("%[", ""):gsub("%]", "")] or "Other"
end

local function GetSilentAimToolSettings()
    local settings = shared.global['WeaponCategories']
    local category = GetWeaponCategory() or "Other"
    return settings[category]['SilentAim'] or settings['Other']['SilentAim']
end

local function GetFovSize(fovTable, distance)
    if distance <= 50 then
        return fovTable['Close']
    elseif distance <= 100 then
        return fovTable['Mid']
    else
        return fovTable['Far']
    end
end

local function GetHitChance(hitChanceTable, distance)
    if distance <= 50 then
        return hitChanceTable['Close']
    elseif distance <= 100 then
        return hitChanceTable['Mid']
    else
        return hitChanceTable['Far']
    end
end

local function getClosestPartToCursor(Player)
    if not Player or not Player.Character or not Player.Character:FindFirstChild("Humanoid") or not Player.Character:FindFirstChild("Head") then
        return nil
    end
    local closestPart, closestDist = nil, math.huge
    if Player.Character.Humanoid.Health > 0 then
        for _, partName in ipairs(ValidBodyParts) do
            local part = Player.Character:FindFirstChild(partName)
            if part then
                local screenPos, cameraVisible = Camera:WorldToViewportPoint(part.Position)
                if cameraVisible then
                    local distToMouse = (Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                    if distToMouse < closestDist then
                        closestPart = part
                        closestDist = distToMouse
                    end
                end
            end
        end
    end
    return closestPart
end

local function GetClosestPlayer(config)
    if IsSelfKnocked() then return nil end
    
    local settings = GetSilentAimToolSettings()
    local maxDistance = settings['Distance']['Max']
    local minDistance = settings['Distance']['Min']
    local fovTable = settings['Fov']
    local hitChanceTable = settings['HitChance']
    
    local closestDistance, closestPart = math.huge, nil
    local mousePosition = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            if not PlayerCheck(player, config) then continue end
            
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if not humanoid or humanoid.Health <= 0 then continue end
            
            local root = player.Character:FindFirstChild("HumanoidRootPart")
            if not root then continue end
            
            local distance = (root.Position - Camera.CFrame.Position).Magnitude
            if distance < minDistance or distance > maxDistance then continue end
            if IsBehindWall(root, config) then continue end
            
            local fovSize = GetFovSize(fovTable, distance)
            local targetPart = nil
            
            if config['AimSettings']['Basic'] and not config['AimSettings']['Advanced'] then
                local partName = config['AimSettings']['TargetPart']
                if table.find(ValidBodyParts, partName) then
                    targetPart = player.Character:FindFirstChild(partName)
                end
            elseif config['AimSettings']['Advanced'] and config['AimSettings']['Method']:lower() == "nearestpart" then
                targetPart = getClosestPartToCursor(player)
            end
            
            if targetPart then
                local screenPos, visible = Camera:WorldToViewportPoint(targetPart.Position)
                if visible then
                    local distToMouse = (mousePosition - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                    if distToMouse <= fovSize and distToMouse < closestDistance then
                        local hitChance = GetHitChance(hitChanceTable, distance)
                        if math.random(1, 100) <= hitChance then
                            closestDistance = distToMouse
                            closestPart = targetPart
                        end
                    end
                end
            end
        end
    end
    
    return closestPart
end

local function IsSharedKeybindPressed(config)
    if config['Controls']['Mode'] == "Always" then
        return true
    end
    local key = config['Controls']['Keybind']
    if key:lower():find("mousebutton") then
        local success, result = pcall(function()
            return UserInputService:IsMouseButtonPressed(Enum.UserInputType[key])
        end)
        return success and result or false
    else
        local success, result = pcall(function()
            return UserInputService:IsKeyDown(Enum.KeyCode[key:upper()])
        end)
        return success and result or false
    end
end

-- Silent Aim Metatable Hook
local grm = getrawmetatable(game)
local index = grm.__index
setreadonly(grm, false)

grm.__index = function(self, Index)
    if not checkcaller() and self == Mouse and shared.global['SilentAim']['Enabled'] then
        if Index == "Hit" or Index == "Target" then
            local config = shared.global['SilentAim']
            local mode = config['Controls']['Mode']:lower()
            local isActive = false
            
            if mode == "hold" then
                isActive = IsSharedKeybindPressed(config)
            elseif mode == "toggle" then
                isActive = silentAimToggleState
            elseif mode == "always" then
                isActive = true
            end
            
            if isActive then
                local targetPart = GetClosestPlayer(config)
                if targetPart then
                    return CFrame.new(targetPart.Position)
                end
            end
        end
    end
    return index(self, Index)
end

setreadonly(grm, true)

-- Silent Aim Input Handling
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe or not shared.global['SilentAim']['Enabled'] then return end
    
    local aimKey = shared.global['SilentAim']['Controls']['Keybind']
    local isMouseAim = aimKey:lower():find("mousebutton")
    if shared.global['SilentAim']['Controls']['Mode'] == "Toggle" then
        if isMouseAim then
            local success, result = pcall(function()
                return input.UserInputType == Enum.UserInputType[aimKey]
            end)
            if success and result then
                silentAimToggleState = not silentAimToggleState
            end
        elseif input.KeyCode == Enum.KeyCode[aimKey:upper()] then
            silentAimToggleState = not silentAimToggleState
        end
    end
end)

-- Silent Aim FOV Circle Update
RunService.RenderStepped:Connect(function()
    if not shared.global['SilentAim']['Enabled'] then
        FOVCircle.Visible = false
        silentAimToggleState = false
        return
    end
    
    local config = shared.global['SilentAim']
    local settings = GetSilentAimToolSettings()
    local distance = Plr and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") and (Plr.Character.HumanoidRootPart.Position - Camera.CFrame.Position).Magnitude or 200
    local fovSize = GetFovSize(settings['Fov'], distance)
    
    FOVCircle.Visible = config['FOV']['Visible']
    FOVCircle.Position = UserInputService:GetMouseLocation()
    FOVCircle.Radius = fovSize
    FOVCircle.Color = config['FOV']['Color']
    FOVCircle.Thickness = config['FOV']['Thickness']
    FOVCircle.Transparency = config['FOV']['Transparency']
end)

-- Aim Assist Logic
local function GetAimAssistToolSettings()
    local settings = shared.global['WeaponCategories']
    local category = GetWeaponCategory() or "Other"
    return settings[category]['AimAssist'] or settings['Other']['AimAssist']
end

local function GetTriggerBotToolSettings()
    local settings = shared.global['WeaponCategories']
    local category = GetWeaponCategory() or "Other"
    return settings[category]['TriggerBot'] or settings['Other']['TriggerBot']
end

local function GetFovSize(fovTable, distance)
    if distance <= 50 then
        return fovTable['Close']
    elseif distance <= 100 then
        return fovTable['Mid']
    else
        return fovTable['Far']
    end
end

local function GetSmoothness(smoothTable, distance)
    if distance <= 50 then
        return smoothTable['Close']
    elseif distance <= 100 then
        return smoothTable['Mid']
    else
        return smoothTable['Far']
    end
end

local function getClosestPlayerToCursor(allowNewTarget, config)
    local settings = GetAimAssistToolSettings()
    local maxDistance = settings['Distance']['Max']
    local minDistance = settings['Distance']['Min']
    local fovTable = settings['Fov']

    if IsSelfKnocked() then
        Plr = nil
        Locking = false
        return nil
    end

    if Plr and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") and Plr.Character:FindFirstChild("Humanoid") then
        local root = Plr.Character.HumanoidRootPart
        local distance = (root.Position - Camera.CFrame.Position).Magnitude
        local screenPos, cameraVisible = Camera:WorldToViewportPoint(root.Position)
        local mousePos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
        local distToMouse = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        local fovSize = GetFovSize(fovTable, distance)

        if distance > maxDistance or distance < minDistance or 
           distToMouse > fovSize or
           not PlayerCheck(Plr, config) or
           IsBehindWall(root, config) or
           (config['Checks']['Reload'] and not IsReloading()) or
           (config['Checks']['ThirdPerson'] and not DisableOnThirdPerson()) or
           (config['Checks']['RequireGun'] and not CheckHoldingGun()) then
            Plr = nil
            Locking = false
            lockCooldown = os.clock() + 0.2
            return nil
        end

        if cameraVisible then
            return Plr
        end
    end

    if not allowNewTarget or os.clock() < lockCooldown then
        return nil
    end

    local closestDist = math.huge
    local closestPlr = nil
    for _, v in ipairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
            if not PlayerCheck(v, config) then continue end
            local root = v.Character:FindFirstChild("HumanoidRootPart")
            if not root then continue end
            if IsBehindWall(root, config) then continue end
            if config['Checks']['Reload'] and not IsReloading() then continue end
            if config['Checks']['ThirdPerson'] and not DisableOnThirdPerson() then continue end
            if config['Checks']['RequireGun'] and not CheckHoldingGun() then continue end

            local distance = (root.Position - Camera.CFrame.Position).Magnitude
            if distance > maxDistance or distance < minDistance then continue end

            local screenPos, cameraVisible = Camera:WorldToViewportPoint(root.Position)
            if cameraVisible then
                local mousePos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                local distToMouse = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                local fovSize = GetFovSize(fovTable, distance)
                if distToMouse <= fovSize and distToMouse < closestDist then
                    closestPlr = v
                    closestDist = distToMouse
                end
            end
        end
    end
    return closestPlr
end

local function SmoothAim(targetPos)
    if not targetPos then return end
    local currentCFrame = Camera.CFrame
    local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)
    
    local distance = Plr and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") and (Plr.Character.HumanoidRootPart.Position - Camera.CFrame.Position).Magnitude or 200
    local settings = GetAimAssistToolSettings()
    local smoothFactor = math.clamp(GetSmoothness(settings['Smoothness'], distance), 0.01, 1)
    
    local elasticFactor = math.clamp(smoothFactor * 0.5, 0.01, 0.5)
    local sineFactor = math.clamp(smoothFactor, 0.01, 1)
    local smoothCFrame = currentCFrame:Lerp(targetCFrame, elasticFactor, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
    smoothCFrame = smoothCFrame:Lerp(targetCFrame, sineFactor, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
    
    Camera.CFrame = smoothCFrame
    if MainEvent then
        MainEvent:FireServer("UpdateMousePosI", targetPos)
    end
end

local function UpdateMousePos()
    local currentMousePos = Vector2.new(Mouse.X, Mouse.Y)
    if currentMousePos ~= lastMousePos then
        lastMousePos = currentMousePos
        return true
    end
    return false
end

-- Aim Assist Render Loop
RunService.RenderStepped:Connect(function()
    if not shared.global['AimAssist']['Enabled'] then
        Plr = nil
        Locking = false
        aimAssistToggleState = false
        return
    end

    local mode = shared.global['AimAssist']['Controls']['Mode']
    local targeting = shared.global['AimAssist']['AimSettings']
    local settings = GetAimAssistToolSettings()
    local maxDistance = settings['Distance']['Max']
    local minDistance = settings['Distance']['Min']
    local fovTable = settings['Fov']
    
    local targetDistance = maxDistance
    if Plr and Plr.Character and Plr.Character:FindFirstChild("HumanoidRootPart") then
        targetDistance = (Plr.Character.HumanoidRootPart.Position - Camera.CFrame.Position).Magnitude
    end
    local fovSize = GetFovSize(fovTable, targetDistance)

    if IsSelfKnocked() then
        Plr = nil
        Locking = false
        aimAssistToggleState = false
        return
    end

    local keyPressed = IsSharedKeybindPressed(shared.global['AimAssist'])
    if mode == "Hold" then
        if keyPressed then
            if not Locking and os.clock() >= lockCooldown then
                Plr = getClosestPlayerToCursor(true, shared.global['AimAssist'])
                Locking = Plr ~= nil
            end
        else
            Plr = nil
            Locking = false
            lockCooldown = os.clock() + 0.2
        end
    elseif mode == "Toggle" then
        if not aimAssistToggleState then
            Plr = nil
            Locking = false
        elseif not Locking and os.clock() >= lockCooldown then
            Plr = getClosestPlayerToCursor(true, shared.global['AimAssist'])
            Locking = Plr ~= nil
        end
    end

    if Locking and Plr and Plr.Character and Plr.Character:FindFirstChild("Humanoid") then
        local root = Plr.Character:FindFirstChild("HumanoidRootPart")
        if not root then
            Plr = nil
            Locking = false
            aimAssistToggleState = false
            lockCooldown = os.clock() + 0.2
            return
        end

        local distance = (root.Position - Camera.CFrame.Position).Magnitude
        local screenPos, cameraVisible = Camera:WorldToViewportPoint(root.Position)
        local mousePos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
        local distToMouse = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        local fovSize = GetFovSize(fovTable, distance)

        if distance > maxDistance or distance < minDistance or 
           distToMouse > fovSize or
           not PlayerCheck(Plr, shared.global['AimAssist']) or
           IsBehindWall(root, shared.global['AimAssist']) or
           (shared.global['AimAssist']['Checks']['Reload'] and not IsReloading()) or
           (shared.global['AimAssist']['Checks']['ThirdPerson'] and not DisableOnThirdPerson()) or
           (shared.global['AimAssist']['Checks']['RequireGun'] and not CheckHoldingGun()) then
            Plr = nil
            Locking = false
            aimAssistToggleState = false
            lockCooldown = os.clock() + 0.2
            return
        end

        local targetPos = nil
        if targeting['Basic'] and not targeting['Advanced'] then
            local bodyPart = targeting['TargetPart']
            if table.find(ValidBodyParts, bodyPart) then
                local part = Plr.Character:FindFirstChild(bodyPart)
                if part then
                    targetPos = part.Position
                end
            end
        elseif targeting['Advanced'] then
            local method = targeting['Method']:lower()
            if method == "nearestpart" then
                if UpdateMousePos() or not targetPos then
                    local part = getClosestPartToCursor(Plr)
                    if part then
                        targetPos = part.Position
                    end
                end
            end
        end

        if targetPos then
            SmoothAim(targetPos)
        else
            Plr = nil
            Locking = false
            aimAssistToggleState = false
            lockCooldown = os.clock() + 0.2
        end
    end
end)

-- Input Handling for Aim Assist
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe or not shared.global['AimAssist']['Enabled'] then return end
    
    local aimKey = shared.global['AimAssist']['Controls']['Keybind']
    local isMouseAim = aimKey:lower():find("mousebutton")
    if shared.global['AimAssist']['Controls']['Mode'] == "Toggle" then
        if isMouseAim then
            local success, result = pcall(function()
                return input.UserInputType == Enum.UserInputType[aimKey]
            end)
            if success and result then
                aimAssistToggleState = not aimAssistToggleState
            end
        elseif input.KeyCode == Enum.KeyCode[aimKey:upper()] then
            aimAssistToggleState = not aimAssistToggleState
        end
    end
end)

-- TriggerBot
local function IsMouseOverValidPlayer()
    local settings = GetTriggerBotToolSettings()
    local maxDistance = settings['Distance']['Max']
    local minDistance = settings['Distance']['Min']
    local fovTable = settings['Fov']
    local toolName = GetEquippedTool()
    if not toolName then return nil end

    local origin = Camera.CFrame.Position
    local direction = (Mouse.Hit.Position - origin).Unit * maxDistance
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character or {}}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    local ray = Workspace:Raycast(origin, direction, params)

    if ray and ray.Instance then
        local character = ray.Instance:FindFirstAncestorOfClass("Model")
        local player = Players:GetPlayerFromCharacter(character)
        if player and player ~= LocalPlayer then
            local root = character:FindFirstChild("HumanoidRootPart")
            if not root then return nil end
            if not PlayerCheck(player, shared.global['TriggerBot']) then return nil end
            if IsBehindWall(root, shared.global['TriggerBot']) then return nil end

            local distance = (root.Position - Camera.CFrame.Position).Magnitude
            if distance > maxDistance or distance < minDistance then return nil end

            local screenPos, cameraVisible = Camera:WorldToViewportPoint(root.Position)
            if not cameraVisible then return nil end
            local mousePos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
            local distToMouse = (mousePos - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
            local fovSize = GetFovSize(fovTable, distance)
            if distToMouse > fovSize then return nil end

            return player
        end
    end
    return nil
end

local function FireWeapon()
    local success = pcall(function()
        mouse1press()
        local delay = shared.global['TriggerBot']['Delay']['Interval']
        if shared.global['TriggerBot']['Delay']['Randomized'] then
            delay = math.random(
                math.floor(shared.global['TriggerBot']['Delay']['Amount']['Min'] * 1000),
                math.floor(shared.global['TriggerBot']['Delay']['Amount']['Max'] * 1000)
            ) / 1000
        end
        task.wait(delay)
        mouse1release()
    end)
end

RunService.RenderStepped:Connect(function()
    if not shared.global['TriggerBot']['Enabled'] then
        if isMouseHeld then
            pcall(function() mouse1release() end)
            isMouseHeld = false
        end
        return
    end

    local mode = shared.global['TriggerBot']['Controls']['Mode']
    local player = IsMouseOverValidPlayer()
    local isAutomatic = GetWeaponCategory() == "Automatics"

    if player then
        if mode == "Hold" then
            if IsSharedKeybindPressed(shared.global['TriggerBot']) then
                if isAutomatic then
                    if not isMouseHeld then
                        pcall(function() mouse1press() end)
                        isMouseHeld = true
                    end
                else
                    FireWeapon()
                end
            elseif isMouseHeld then
                pcall(function() mouse1release() end)
                isMouseHeld = false
            end
        elseif mode == "Toggle" then
            if toggleState then
                if isAutomatic then
                    if not isMouseHeld then
                        pcall(function() mouse1press() end)
                        isMouseHeld = true
                    end
                else
                    FireWeapon()
                end
            elseif isMouseHeld then
                pcall(function() mouse1release() end)
                isMouseHeld = false
            end
        end
    else
        if isMouseHeld then
            pcall(function() mouse1release() end)
            isMouseHeld = false
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe or not shared.global['TriggerBot']['Enabled'] then return end
    local key = shared.global['TriggerBot']['Controls']['Keybind']
    local isMouse = key:lower():find("mousebutton")
    if shared.global['TriggerBot']['Controls']['Mode'] == "Toggle" then
        if isMouse then
            local success, result = pcall(function()
                return input.UserInputType == Enum.UserInputType[key]
            end)
            if success and result then
                toggleState = not toggleState
                if not toggleState and isMouseHeld then
                    pcall(function() mouse1release() end)
                    isMouseHeld = false
                end
            end
        elseif input.KeyCode == Enum.KeyCode[key:upper()] then
            toggleState = not toggleState
            if not toggleState and isMouseHeld then
                pcall(function() mouse1release() end)
                isMouseHeld = false
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
    if gpe or not shared.global['TriggerBot']['Enabled'] then return end
    local key = shared.global['TriggerBot']['Controls']['Keybind']
    if shared.global['TriggerBot']['Controls']['Mode'] == "Hold" then
        if (input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode[key:upper()]) or
           (key:lower():find("mousebutton") and input.UserInputType == Enum.UserInputType[key]) then
            if isMouseHeld then
                pcall(function() mouse1release() end)
                isMouseHeld = false
            end
        end
    end
end)

-- Set FPS cap
setfpscap(333)
